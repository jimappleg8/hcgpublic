#!/usr/bin/perl############################################################################# Send a Postcard, written by Matt Atwater# comments added by Jim Applegate############################################################################## The URL calling this script requires a "GO" field. The options are # FORM, POSTCARD, save_request. If FORM is called, then an HTML form is # generated to# allow someone to create a postcard and send it to a friend. If POSTCARD# is called, then the previously created postcard is displayed.#############################################################################$HOME = "/var/opt/httpd/csdocs/justforfun";$ip = "http://postcard.celestialseasonings.com";$this = "/cgi-bin/postcard.pl";$QUOTES = "$HOME/e-postcards/quotes.txt";$NOSUB="<HTML>\n<HEAD>\n<TITLE>Unable to Process!</TITLE>\n</HEAD>\n	<BODY BGCOLOR=#FFFFFF BACKGROUND=\"/images/site/background.jpg\">\n	<P>&nbsp;\n	<H3 ALIGN=CENTER>Unable to process your Postcard Request!</H3>\n	<P>\n	<H3 ALIGN=CENTER>Please hit your browser's back button and try again!</H3>	<P>	</BODY>\n</HTML>";     $agent = $ENV{"HTTP_USER_AGENT"};     $req   = $ENV{"REQUEST_METHOD"};     $out_buf = "";     if ($req eq "GET") {        $query_s = $ENV{"QUERY_STRING"};     } elsif ($ENV{'CONTENT_LENGTH'} =~ /[0-9]+/) {        read(STDIN, $query_s, $ENV{'CONTENT_LENGTH'});#        $l = 0 + $ENV{'CONTENT_LENGTH'};#        $query_s = "";#        if ($l < 10000) {#           while ($l--) { $query_s .= getc(STDIN) }#        }     }     %q = html::parse($query_s);      $cook    = $ENV{"HTTP_COOKIE"};     %cks = html::parse_cookies($cook);       # the all-important header to generate an HTML file   print "Content-type: text/html\n\n\n";        # check the GO field and call the appropriate subroutine    $f = $q{GO};   if ($f eq "") {      print $NOSUB;     } else {      &$f;   }############################################################################# Subroutine: POSTCARD ()# Generates an HTML postcard page based on data stored in the postcard# file saved in ___. It knows what file by the URL supplied by the receiver# of the postcard notice.#############################################################################sub POSTCARD {#  print "<h3>to=$q{to},from=$q{from}, letter=$q{letter}, pic=$q{CARD}, mess=$q{message}";   # decode the message line to convert %2F to the slash character   $message = html::decode($q{message});#  print "mess=$message<br>";   # open the postcard file based on the message code.   if (! open(O,"$HOME/Message/$message") ) {       print "<b>Cannot read message file $message <br>";       return;   }      # divide the postcard file into it's parts.   $l = <O>;   ($card,$letter,$to,$toemail,$from,$fromemail) = split(/ /,$l);#  print "card=$card,letter = $letter<br>";   $card = html::decode($card);   $stamp = "bear" . $card;#  $card .= "0";   $to = html::decode($to);   $toemail = html::decode($toemail);   $from = html::decode($from);   $fromemail = html::decode($fromemail);   $mess = <O>;   close(O);   $quotes = &get_quote($card,$letter);#  print "card=$card,letter = $letter quote=$quotes<br>";     print <<EOF;   <body bgcolor=#ffffff background=/images/site/background.jpg marginheight=0 topmargin=0>   <table border=0 cellspacing=0>   <tr>   		<td valign=top width=266>			<img src=/justforfun/e-postcards/images/${card}-a.jpg>			<BR><BR>			<a href="http://www.celestialseasonings.com" TARGET=top>          	<img src=/justforfun/e-postcards/images/bearclic.gif align=bottom border=0></a>		</td>		<td valign=top width=350>			<img src=/justforfun/e-postcards/images/grn_from.gif>									<table border=0 cellspacing=0 cellpadding=2 width=330 HEIGHT=220>			<tr>				<td bgcolor=black>             	<table border=0 cellspacing=2 WIDTH=330 cellpadding=2>                 <tr>				 	<td bgcolor=white height=220 valign=top width=50%>					<center><br>                    $quotes<p> $mess<p>                    From $from                     </td>                    <td valign=top bgcolor=white>					<center>                    <img src=/justforfun/e-postcards/images/$stamp.gif><br>                    To: <b>$to</b> <br> $toemail                    </td>				  </tr>                </table>			    </td>			 </tr>           </table>					</td>        </tr>    </table>EOF  close(O);}############################################################################# Subroutine: get_quote ($card, $letter)# Returns an HTML table of quotes based on the card style chosen. The quotes# are pulled from a fixed-length database. This is called by FORM with ""# specified as $letter, while POSTCARD calls it with a specific letter.#############################################################################sub get_quote {	my($card,$letter) = @_;	my($quotes);	if (! open(O,$QUOTES)) {		print "<b>Cannot open $QUOTES";		return;	}	$quotes = "<table border=0 cellspacing=0 cellpadding=4>";	while ($l = <O>) {		chop($l);		$cnt = substr($l,0,5) + 0;		$name = substr($l,5,20);		$let = substr($l,25,1);		if ($letter ne "" and $let ne $letter) {next}		$author = substr($l,29,40);		$text = substr($l,69);		# if the entry is the 		if ((trim($name) eq $card) and ($card ne "") 			and ($author !~ /^ *$/)) {			if ($letter eq "") {				$quotes .= "<tr><td><font face=arial><font size=+1><b>$let</b></font> ";			} else {				$quotes .= "<tr><td><font face=arial> ";			}			$quotes .= "<font face=arial size=-1>\"$text\"<b><br>";			$quotes .= " - $author </td>\n";			$Quotes{$let} = $author;		}	}	# alternative version of above	# 	close(O);	$quotes .= "</table>";}############################################################################# Subroutine: FORM ()# Generates the HTML form that then allows the user to create a postcard# and send it to someone.#############################################################################sub FORM {  $quotes = &get_quote($q{CARD},"");  @letters = (A,B,C,D,E,F,G,H);  $select = "";  for $i (@letters) {      if ($Quotes{$i} !~ /^ *$/) {         $select .= "<option value=$i>$i - $Quotes{$i}";      }  }  $form =<<EOF;   <body background=/images/site/background.jpg>   <table border=0 cellspacing=0>   <form action=$this method=post>    $error	<tr>      <td></td>      <td COLSPAN=3 align=top><CENTER><font face=arial size=-2>	  <b>Quote: <select name=letter>$select</select></CENTER></td>   </tr>   <tr>      <td align=right><font face=arial size=-2><b>To: </td>      <td><font face=arial size=-2><input type=text size=15 name=to> </td>	  <td align=right><font face=arial size=-2><b>email: </td>      <td><font face=arial size=-2><input type=text size=15 name=toemail> </td>   </tr>   <tr>      <td align=right><font face=arial size=-2><b>From: </td>      <td><font face=arial size=-2><input type=text size=15 name=from> </td>	  <td align=right><font face=arial size=-2><b>email: </td>      <td><font face=arial size=-2><input type=text size=15 name=fromemail> </td>   </tr>   <tr>      <td align=right></td>      <td colspan=4><font face=arial size=-2>	  <b>Message: <BR>      <textarea name=message rows=3 cols=37 wrap=virtual></textarea></td>   </tr>   <tr>   </tr>   <td></td>   <td colspan=3><center><input type=submit value=Submit></center></td>   </table>   <input type=hidden name=GO value=save_request>   <input type=hidden name=CARD value=$q{CARD}>   </form>EOF          $error = "";    print <<EOF;<HTML><HEAD><TITLE>Send a Postcard to a Friend!</TITLE></HEAD><BODY BGCOLOR=#FFFFFF BACKGROUND="/images/site/background.jpg" LINK="#003399"><CENTER><TABLE WIDTH=600 BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR>     <TD COLSPAN=2 ALIGN=CENTER>        <IMG SRC="/justforfun/e-postcards/images/mark.gif" WIDTH=146 HEIGHT=109 	  ALT="postmark Boulder, Colorado">	<IMG SRC="/justforfun/e-postcards/images/grn_send.gif" WIDTH="181" HEIGHT="92" 	  ALT="send a Postcard to a Friend" BORDER=0><TR>   <td width=200 valign=top>$quotes </td>    <td valign=top>&nbsp; &nbsp; &nbsp; &nbsp;           <img src=/justforfun/e-postcards/images/$q{CARD}.jpg border=0><br>            $form </td>  </table></BODY></HTML>EOF}############################################################################# Subroutine: save_request ()# Save a postcard request in a mail message.#############################################################################sub save_request {   # check to make sure the TO address appears valid.   if ($q{toemail} eq "" or $q{toemail} !~ /\@/){       $error = "<tr><td colspan=4><center><font color=red face=arial>The 'to' email address is invalid.</td>";      &FORM;   }   # then check to see that a FROM name was entered.   elsif ($q{from} eq "") {      $error = "<tr><td colspan=4><center><font color=red face=arial>'From' is required.</td>";      &FORM;   }   # if the FROM address is not entered, make it "unknown"   else {   if ($q{fromemail} !~ /.+\@.+\..+/) {      $q{fromemail} = "Unknown";   }         $q{message} =~ s/\r\n/ /g;#   $q{message} = html::encode2($q{message});   $q{to} = html::encode2($q{to});   $toemail = $q{toemail};   $q{toemail} = html::encode2($q{toemail});   $from = $q{from};   $q{from} = html::encode2($q{from});   $fromemail = $q{fromemail};   $q{fromemail} = html::encode2($q{fromemail});      # generate the key used as the file name and the message indicator   $key = "$$-" . time;   $dir = substr($key,length($key)-2,2);   $key = "$dir/$key"; chop($key); chop($key);   $key0 = html::encode($key);   $to = html::decode($q{to});   $o =<<EOF;Subject: You have a postcard     ---------------------------------------------------------    |   Dear $to,    |    |   You have a Celestial Seasonings postcard           |   from '$from' waiting for you     |   at the following address.    ---------------------------------------------------------    $ip$this?GO=POSTCARD&message=$key0EOF   #if (! open(O,"$HOME/Message/$key") ) {    # print "unable to open file $HOME/Message/$key";   #}   #close(0);   if (open(PFILE,">$HOME/Message/$key")) {      print PFILE "$q{CARD} $q{letter} $q{to} $q{toemail} $q{from} $q{fromemail}\n";      print PFILE $q{message};      close(PFILE);   } else {      print "unable to open file $HOME/Message/$key";   }   if (open(MAIL, "|sendmail -f$fromemail -F\"$from\" $toemail")) {     print MAIL $o;     close(MAIL);     print "<html><body bgcolor=#ffffff background=/images/site/background.jpg><center>&nbsp;<p>&nbsp;<p>         <h3>Thank you!<br>         Your postcard will be mailed immediately<BR><BR>		 <A HREF=\"http://www.celestialseasonings.com/justforfun/e-postcards/\">Send another postcard?</a><br><br><A HREF=\"http://www.celestialseasonings.com/\">Return to Home Page</a><center></html>";   } else {      print "<html>Error: $!<br>";   } }}# ADMIN: QUOTE MAINTENANCE############################################################################# Subroutine: set_quotes ()#############################################################################sub set_quotes {    open(O,$QUOTES);  while ($l = <O>) {     chop($l);     $cnt = substr($l,0,5) + 0;     $name = substr($l,5,20);     $letter = substr($l,25,4);     $author = substr($l,29,40);     $text = substr($l,69);     $letter = substr($letter,0,1);     $name[$cnt] = $name;     $p{$cnt . $letter} = {author => $author, text =>$text};  }  close(O);   print "<html><head><title> PostCard Quotes</title><body>         <form action=$this method=post><center>         <table border=0 cellspacing=2 ><tr><td bgcolor=black>         <table border=0 cellspacing=1 cellpadding=1 width=100%>";  for ($x=0; $x <= (scalar(@name) - 1); $x++) {     $xplus1 = $x+1;     print "<tr><td align=right bgcolor=black><font color=white><b>Name of Picture $xplus1 :</td>                <td colspan=3 bgcolor=black>                     <input type=text name=name$x size=20 value=$name[$x]></td>";     $let = "ABCDE";     for ($y =0; $y <= 4; $y++) {         $let0 = substr($let,$y,1);         $l = $p{$x . $let0};         print <<EOF;                <tr>                <td align=right bgcolor=#9bCECE><b>Selection Letter :</td>                <td bgcolor=white>&nbsp; $let0 &nbsp;</td>                <td align=right bgcolor=#9bCECE><b> Author :</td>                <td bgcolor=white>                   <input type=text name=author$x$let0 size=35 value="$l->{author}"></td>                <tr>                <td align=right bgcolor=#9bCECE><b>Text :</td>                <td colspan=3 bgcolor=white>                   <textarea  wrap=virtual name=text$x$let0 rows=3 cols=50>$l->{text}</textarea></td>EOF     }  }  print "<input type=hidden name=GO value=store_quotes>        </table> </table> <input type=submit value=Submit></form>";}############################################################################# Subroutine: store_quotes ()#  Write the quotes#############################################################################sub store_quotes {  foreach $x (keys %q) {     if (substr($x,0,4) eq "name") {       $pno = substr($x,4) + 0;       $name[$pno] = $q{$x};     } elsif (substr($x,0,6) eq "author") {       $pno = substr($x,6,1)  + 0;       $lno = substr($x,7,1);       $author{$pno. $lno} = $q{$x};     } elsif (substr($x,0,4 ) eq "text") {       $pno = substr($x,4,1)  + 0;       $lno = substr($x,5,1);       $q{$x} =~ s/\r\n/ /g;       $text{$pno. $lno} = $q{$x};     }  }  if (! open(O,">$QUOTES") ) {     print "<BR> <b>Cannot write to file $QUOTES !";     return;  }  foreach $x (sort keys %text) {    $p = substr($x,0,1);    $l = substr($x,1,1);    printf O "%-5.5s%-20.20s%-4.4s%-40.40s%s\n" ,              substr($x,0,1),              $name[$p],              $l,              $author{$x},              $text{$x} ;  }  close(O);  &set_quotes;}              ############################################################################# Subroutine: trim ()#  Taken from Perl Cookbook, p.30. This subroutine will trim leading and#  trailing spaces from either a string or an array of strings:#		$string = trim($string);#		@many = trim(@many);#############################################################################sub trim {	my @out = @_;	for (@out) {		s/^\s+//;		s/\s+$//;	}	return wantarray ? @out : $out[0];}     package html;sub encode2 {  my($s) = @_;     $s =~ s/(\W)/uc(sprintf("%%%x",ord($1)))/eg;  $s;}sub encode {  local($s) = @_;  $s =~ s/\%/%25/g;  $s =~ s/\#/%23/g;  $s =~ s/\+/%2B/g;  $s =~ s/ /\+/g;  $s =~ s/\?/%3F/g;  $s =~ s/\&/%26/g;  $s =~ s/\//%2F/g;  $s;}sub decode {  local($s) = @_;  $s =~ s/\+/ /g;  $s =~ s/%([0-9|A-F]{2})/pack(C,hex($1))/eg;  $s;}sub parse_cookies {  my($query_s) = @_;  my(%cks);    foreach (split(/; */,$query_s)) {     ($NAME,$VALUE) = split(/=/, $_);     $cks{$NAME} = $VALUE;  }  return %cks;}sub parse {  my($query_s) = @_;  my($cnt, %q);     foreach (split(/&/,$query_s)) {     ($NAME,$VALUE) = split(/=/, $_);     $NAME =~ s/\+/ /g;     $NAME =~ s/%([0-9\.|A-F]{2})/pack(C,hex($1))/eg;          $VALUE =~ s/\+/ /g;     $VALUE =~ s/%([0-9|A-F]{2})/pack(C,hex($1))/eg;     $q{$NAME} = $VALUE;       }  return %q;}