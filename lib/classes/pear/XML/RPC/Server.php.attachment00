    function verifySignature($in, $sig)    {        for ($i = 0; $i < sizeof($sig); $i++) {            // check each possible signature in turn            $cursig = $sig[$i];            if (sizeof($cursig) == $in->getNumParams() + 1) {                $itsOK = 1;                for ($n = 0; $n < $in->getNumParams(); $n++) {                    $p = $in->getParam($n);                    // print "<!-- $p -->\n";                    if ($p->kindOf() == "scalar") {                        $pt = $p->scalartyp();                    } else {                        $pt = $p->kindOf();                    }                    // $n+1 as first type of sig is return type                    if ($pt != $cursig[$n+1]) {                        $itsOK = 0;                        $pno = $n+1;                        $wanted = $cursig[$n+1];                        $got = $pt;                        break;                    }                }                if ($itsOK)                    return array(1);            }        }        return array(0, "Wanted ${wanted}, got ${got} at param ${pno})");    }    function parseRequest($data = "")    {        global $XML_RPC_xh,$HTTP_RAW_POST_DATA;        global $XML_RPC_err, $XML_RPC_str, $XML_RPC_errxml,            $XML_RPC_defencoding, $XML_RPC_Server_dmap;        if ($data == "") {            $data = $HTTP_RAW_POST_DATA;        }        $parser = xml_parser_create($XML_RPC_defencoding);        $XML_RPC_xh[$parser] = array();        $XML_RPC_xh[$parser]['st'] = "";        $XML_RPC_xh[$parser]['cm'] = 0;        $XML_RPC_xh[$parser]['isf'] = 0;        $XML_RPC_xh[$parser]['params'] = array();        $XML_RPC_xh[$parser]['method'] = "";        $plist = '';        // decompose incoming XML into request structure        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, true);        xml_set_element_handler($parser, "XML_RPC_se", "XML_RPC_ee");        xml_set_character_data_handler($parser, "XML_RPC_cd");        xml_set_default_handler($parser, "XML_RPC_dh");        if (!xml_parse($parser, $data, 1)) {            // return XML error as a faultCode            $r = new XML_RPC_Response(0,                                      $XML_RPC_errxml+xml_get_error_code($parser),                                      sprintf("XML error: %s at line %d",                                              xml_error_string(xml_get_error_code($parser)),                                              xml_get_current_line_number($parser)));            xml_parser_free($parser);        } else {            xml_parser_free($parser);            $m = new XML_RPC_Message($XML_RPC_xh[$parser]['method']);            // now add parameters in            for ($i = 0; $i < sizeof($XML_RPC_xh[$parser]['params']); $i++) {                // print "<!-- " . $XML_RPC_xh[$parser]['params'][$i]. "-->\n";                $plist .= "$i - " . $XML_RPC_xh[$parser]['params'][$i] . " \n";                eval('$m->addParam(' . $XML_RPC_xh[$parser]['params'][$i] . ");");            }            XML_RPC_Server_debugmsg($plist);            // now to deal with the method            $methName = $XML_RPC_xh[$parser]['method'];            if (ereg("^system\.", $methName)) {                $dmap = $XML_RPC_Server_dmap;                $sysCall = 1;            } else {                $dmap = $this->dmap;                $sysCall = 0;            }            if (isset($dmap[$methName]['function'])) {                // dispatch if exists                if (isset($dmap[$methName]['signature'])) {                    $sr = $this->verifySignature($m,                                                 $dmap[$methName]['signature'] );                }                if ( (!isset($dmap[$methName]['signature'])) || $sr[0]) {                    // if no signature or correct signature                    if ($sysCall) {                        eval('$r=' . $dmap[$methName]['function'] . '($this, $m);');                    } else {                        eval('$r=' . $dmap[$methName]['function'] . '($m);');                    }                } else {                    $r = new XML_RPC_Response(0, $XML_RPC_err["incorrect_params"],                                                 $XML_RPC_str["incorrect_params"] .                                                 ": " . $sr[1]);                }            } else {                // else prepare error response                $r = new XML_RPC_Response(0, $XML_RPC_err["unknown_method"],                                             $XML_RPC_str["unknown_method"]);            }        }        return $r;    }  function echoInput() {        global $HTTP_RAW_POST_DATA;        // a debugging routine: just echos back the input        // packet as a string value        $r = new XML_RPC_Response;        $r->xv = new XML_RPC_Value("'Aha said I: '" . $HTTP_RAW_POST_DATA, "string");        print $r->serialize();  }}?>