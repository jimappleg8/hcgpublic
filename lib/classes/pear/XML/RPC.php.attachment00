        if (!fputs($fp, $op, strlen($op))) {            $this->errstr = "Write error";            return 0;        }        $resp = $msg->parseResponseFile($fp);        fclose($fp);        return $resp;    }}class XML_RPC_Response extends XML_RPC_Base{    var $xv;    var $fn;    var $fs;    var $hdrs;    function XML_RPC_Response($val, $fcode = 0, $fstr = "")    {        if ($fcode != 0) {            $this->fn = $fcode;            $this->fs = htmlspecialchars($fstr);        } else {            $this->xv = $val;        }    }    function faultCode()    {        if (isset($this->fn)) {            return $this->fn;        } else {            return 0;        }    }    function faultString()    {        return $this->fs;    }    function value()    {        return $this->xv;    }    function serialize()    {        $rs = "<methodResponse>\n";        if ($this->fn) {            $rs .= "<fault>  <value>    <struct>      <member>        <name>faultCode</name>        <value><int>" . $this->fn . "</int></value>      </member>      <member>        <name>faultString</name>        <value><string>" . $this->fs . "</string></value>      </member>    </struct>  </value></fault>";        } else {            $rs .= "<params>\n<param>\n" . $this->xv->serialize() .        "</param>\n</params>";        }        $rs .= "\n</methodResponse>";        return $rs;    }}class XML_RPC_Message extends XML_RPC_Base{    var $payload;    var $methodname;    var $params = array();    var $debug = 0;    function XML_RPC_Message($meth, $pars = 0)    {        $this->methodname = $meth;        if (is_array($pars) && sizeof($pars)>0) {            for($i = 0; $i < sizeof($pars); $i++) {                $this->addParam($pars[$i]);            }        }    }    function xml_header()    {        return "<?xml version=\"1.0\"?>\n<methodCall>\n";    }    function xml_footer()    {        return "</methodCall>\n";    }    function createPayload()    {        $this->payload = $this->xml_header();        $this->payload .= "<methodName>" . $this->methodname . "</methodName>\n";        $this->payload .= "<params>\n";        for($i = 0; $i < sizeof($this->params); $i++) {            $p = $this->params[$i];            $this->payload .= "<param>\n" . $p->serialize() . "</param>\n";        }        $this->payload .= "</params>\n";        $this->payload .= $this->xml_footer();        $this->payload = str_replace("\n", "\r\n", $this->payload);    }    function method($meth = "")    {        if ($meth != "") {            $this->methodname = $meth;        }        return $this->methodname;    }    function serialize()    {        $this->createPayload();        return $this->payload;    }    function addParam($par)    {        $this->params[] = $par;    }    function getParam($i)    {        return $this->params[$i];    }    function getNumParams()    {        return sizeof($this->params);    }    function parseResponseFile($fp)    {        $ipd = "";        while($data = fread($fp, 32768)) {            $ipd .= $data;        }        return $this->parseResponse($ipd);    }    function parseResponse($data = "")    {        global $XML_RPC_xh,$XML_RPC_err,$XML_RPC_str;        global $XML_RPC_defencoding;        $parser = xml_parser_create($XML_RPC_defencoding);        $XML_RPC_xh[$parser] = array();        $XML_RPC_xh[$parser]['st'] = "";        $XML_RPC_xh[$parser]['cm'] = 0;        $XML_RPC_xh[$parser]['isf'] = 0;        $XML_RPC_xh[$parser]['ac'] = "";        $XML_RPC_xh[$parser]['qt'] = "";        xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, true);        xml_set_element_handler($parser, "XML_RPC_se", "XML_RPC_ee");        xml_set_character_data_handler($parser, "XML_RPC_cd");        xml_set_default_handler($parser, "XML_RPC_dh");        $xmlrpc_value = new XML_RPC_Value;        $hdrfnd = 0;        if ($this->debug) {            print "<PRE>---GOT---\n";            print isset($_SERVER['SERVER_PROTOCOL']) ? htmlspecialchars($data) : $data;            print "\n---END---\n</PRE>";        }        // see if we got an HTTP 200 OK, else bomb        // but only do this if we're using the HTTP protocol.        if (ereg("^HTTP",$data) &&            !ereg("^HTTP/[0-9\.]+ 200 ", $data)) {                $errstr = substr($data, 0, strpos($data, "\n")-1);                error_log("HTTP error, got response: " . $errstr);                $r = new XML_RPC_Response(0, $XML_RPC_err["http_error"],                                          $XML_RPC_str["http_error"] . " (" .                                          $errstr . ")");                xml_parser_free($parser);                return $r;        }        // gotta get rid of headers here        if ((!$hdrfnd) && ($brpos = strpos($data,"\r\n\r\n"))) {            $XML_RPC_xh[$parser]['ha'] = substr($data, 0, $brpos);            $data = substr($data, $brpos + 4);            $hdrfnd = 1;        }        // be tolerant of junk after methodResponse (e.g. javascript automatically inserted by free hosts)        // thanks to Luca Mariano <luca.mariano@email.it>        $data = substr($data, 0, strpos($data, "</methodResponse>") + 17);        if (!xml_parse($parser, $data, sizeof($data))) {            // thanks to Peter Kocks <peter.kocks@baygate.com>            if ((xml_get_current_line_number($parser)) == 1) {                $errstr = "XML error at line 1, check URL";            } else {                $errstr = sprintf("XML error: %s at line %d",                                  xml_error_string(xml_get_error_code($parser)),                                  xml_get_current_line_number($parser));            }            error_log($errstr);            $r = new XML_RPC_Response(0, $XML_RPC_err["invalid_return"],                                      $XML_RPC_str["invalid_return"]);            xml_parser_free($parser);            return $r;        }        xml_parser_free($parser);        if ($this->debug) {            print "<PRE>---EVALING---[" .            strlen($XML_RPC_xh[$parser]['st']) . " chars]---\n" .            htmlspecialchars($XML_RPC_xh[$parser]['st']) . ";\n---END---</PRE>";        }        if (strlen($XML_RPC_xh[$parser]['st']) == 0) {            // then something odd has happened            // and it's time to generate a client side error            // indicating something odd went on            $r = new XML_RPC_Response(0, $XML_RPC_err["invalid_return"],                                         $XML_RPC_str["invalid_return"]);        } else {            eval('$v=' . $XML_RPC_xh[$parser]['st'] . '; $allOK=1;');            if ($XML_RPC_xh[$parser]['isf']) {                $f = $v->structmem("faultCode");                $fs = $v->structmem("faultString");                $r = new XML_RPC_Response($v, $f->scalarval(),                                              $fs->scalarval());            } else {                $r = new XML_RPC_Response($v);            }        }        $r->hdrs = split("\r?\n", $XML_RPC_xh[$parser]['ha'][1]);        return $r;    }}class XML_RPC_Value extends XML_RPC_Base{    var $me = array();    var $mytype = 0;    function XML_RPC_Value($val = -1, $type = "")    {        global $XML_RPC_Types;        $this->me = array();        $this->mytype = 0;        if ($val != -1 || $type != "") {            if ($type == "") {                $type="string";            }            if ($XML_RPC_Types[$type] == 1) {                $this->addScalar($val,$type);            } elseif ($XML_RPC_Types[$type] == 2) {                $this->addArray($val);            } elseif ($XML_RPC_Types[$type] == 3) {                $this->addStruct($val);            }        }    }    function addScalar($val, $type = "string")    {        global $XML_RPC_Types, $XML_RPC_Boolean;        if ($this->mytype == 1) {            $this->raiseError("Scalar can have only one value", XML_RPC_ERROR_INVALID_TYPE);            return 0;        }        $typeof = $XML_RPC_Types[$type];        if ($typeof != 1) {            $this->raiseError("Not a scalar type (${typeof})", XML_RPC_ERROR_INVALID_TYPE);            return 0;        }        if ($type == $XML_RPC_Boolean) {            if (strcasecmp($val,"true") == 0 ||                $val == 1 ||                ($val == true &&                    strcasecmp($val,"false"))) {                $val = 1;            } else {                $val = 0;            }        }        if ($this->mytype == 2) {            // we're adding to an array here            $ar = $this->me["array"];            $ar[] = new XML_RPC_Value($val, $type);            $this->me["array"] = $ar;        } else {            // a scalar, so set the value and remember we're scalar            $this->me[$type] = $val;            $this->mytype = $typeof;        }        return 1;    }    function addArray($vals)    {        global $XML_RPC_Types;        if ($this->mytype != 0) {            $this->raiseError(                "Already initialized as a [" . $this->kindOf() . "]",                XML_RPC_ERROR_ALREADY_INITIALIZED);            return 0;        }        $this->mytype = $XML_RPC_Types["array"];        $this->me["array"] = $vals;        return 1;    }    function addStruct($vals)    {        global $XML_RPC_Types;        if ($this->mytype != 0) {            $this->raiseError(                "Already initialized as a [" . $this->kindOf() . "]",                XML_RPC_ERROR_ALREADY_INITIALIZED);            return 0;        }        $this->mytype = $XML_RPC_Types["struct"];        $this->me["struct"] = $vals;        return 1;    }    function dump($ar)    {        reset($ar);        while (list( $key, $val ) = each($ar)) {            echo "$key => $val<br>";            if ($key == 'array') {                while ( list( $key2, $val2 ) = each( $val ) ) {                    echo "-- $key2 => $val2<br>";                }            }        }    }    function kindOf()    {        switch ($this->mytype) {        case 3:            return "struct";            break;        case 2:            return "array";            break;        case 1:            return "scalar";            break;        default:            return "undef";        }    }    function serializedata($typ, $val)    {        $rs = "";        global $XML_RPC_Types, $XML_RPC_Base64, $XML_RPC_String, $XML_RPC_Boolean;        switch ($XML_RPC_Types[$typ]) {        case 3:            // struct            $rs .= "<struct>\n";            reset($val);            while(list($key2, $val2) = each($val)) {                $rs .= "<member><name>${key2}</name>\n";                $rs .= $this->serializeval($val2);                $rs .= "</member>\n";            }            $rs .= "</struct>";            break;        case 2:            // array            $rs .= "<array>\n<data>\n";            for($i = 0; $i < sizeof($val); $i++) {                $rs .= $this->serializeval($val[$i]);            }            $rs .= "</data>\n</array>";            break;        case 1:            switch ($typ) {            case $XML_RPC_Base64:                $rs .= "<${typ}>" . base64_encode($val) . "</${typ}>";                break;            case $XML_RPC_Boolean:                $rs .= "<${typ}>" . ($val ? "1" : "0") . "</${typ}>";                break;            case $XML_RPC_String:                $rs .= "<${typ}>" . htmlspecialchars($val). "</${typ}>";                break;            default:                $rs .= "<${typ}>${val}</${typ}>";            }            break;        default:            break;        }        return $rs;    }    function serialize()    {        return $this->serializeval($this);    }    function serializeval($o)    {        $rs = "";        $ar = $o->me;        reset($ar);        list($typ, $val) = each($ar);        $rs .= "<value>";        $rs .= $this->serializedata($typ, $val);        $rs .= "</value>\n";        return $rs;    }    function structmem($m)    {        $nv = $this->me["struct"][$m];        return $nv;    }    function structreset()    {        reset($this->me["struct"]);    }    function structeach()    {        return each($this->me["struct"]);    }    function getval() {        // UNSTABLE        global $XML_RPC_BOOLEAN, $XML_RPC_Base64;        reset($this->me);        list($a,$b) = each($this->me);        // contributed by I Sofer, 2001-03-24        // add support for nested arrays to scalarval        // i've created a new method here, so as to        // preserve back compatibility        if (is_array($b)) {            foreach ($b as $id => $cont) {                $b[$id] = $cont->scalarval();            }        }        // add support for structures directly encoding php objects        if (is_object($b)) {            $t = get_object_vars($b);            foreach ($t as $id => $cont) {                $t[$id] = $cont->scalarval();            }            foreach ($t as $id => $cont) {                eval('$b->'.$id.' = $cont;');            }        }        // end contrib        return $b;    }    function scalarval()    {        global $XML_RPC_Boolean, $XML_RPC_Base64;        reset($this->me);        list($a,$b) = each($this->me);        return $b;    }    function scalartyp()    {        global $XML_RPC_I4, $XML_RPC_Int;        reset($this->me);        list($a,$b) = each($this->me);        if ($a == $XML_RPC_I4) {            $a = $XML_RPC_Int;        }        return $a;    }    function arraymem($m)    {        $nv = $this->me["array"][$m];        return $nv;    }    function arraysize()    {        reset($this->me);        list($a,$b) = each($this->me);        return sizeof($b);    }}/** * date helpers */function XML_RPC_iso8601_encode($timet, $utc = 0) {    // return an ISO8601 encoded string    // really, timezones ought to be supported    // but the XML-RPC spec says:    //    // "Don't assume a timezone. It should be specified by the server in its    // documentation what assumptions it makes about timezones."    //    // these routines always assume localtime unless    // $utc is set to 1, in which case UTC is assumed    // and an adjustment for locale is made when encoding    if (!$utc) {        $t = strftime("%Y%m%dT%H:%M:%S", $timet);    } else {        if (function_exists("gmstrftime")) {            // gmstrftime doesn't exist in some versions            // of PHP            $t = gmstrftime("%Y%m%dT%H:%M:%S", $timet);        } else {            $t = strftime("%Y%m%dT%H:%M:%S", $timet - date("Z"));        }    }    return $t;}function XML_RPC_iso8601_decode($idate, $utc = 0) {    // return a timet in the localtime, or UTC    $t = 0;    if (ereg("([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})", $idate, $regs)) {        if ($utc) {            $t = gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);        } else {            $t = mktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);        }    }    return $t;}/** * Takes a message in PHP XML_RPC object format and translates it into native PHP types. * * @author Dan Libby <dan@libby.com> **/function XML_RPC_decode($XML_RPC_val) {    $kind = $XML_RPC_val->kindOf();   if ($kind == "scalar") {      return $XML_RPC_val->scalarval();   } elseif ($kind == "array") {      $size = $XML_RPC_val->arraysize();      $arr = array();      for($i = 0; $i < $size; $i++) {         $arr[] = XML_RPC_decode($XML_RPC_val->arraymem($i));      }      return $arr;   } elseif ($kind == "struct") {      $XML_RPC_val->structreset();      $arr = array();      while(list($key,$value) = $XML_RPC_val->structeach()) {         $arr[$key] = XML_RPC_decode($value);      }      return $arr;   }}/** * Takes native php types and encodes them into XML_RPC PHP object format. * * Feature creep -- could support more types via optional type argument. * * @author Dan Libby <dan@libby.com> **/function XML_RPC_encode($php_val) {   global $XML_RPC_Boolean;   global $XML_RPC_Int;   global $XML_RPC_Double;   global $XML_RPC_String;   global $XML_RPC_Array;   global $XML_RPC_Struct;   $type = gettype($php_val);   $XML_RPC_val = new XML_RPC_Value;   switch ($type) {   case "array":       $keys = array_keys($php_val);       $count = count($php_val);       $firstkey = $keys[0];       $lastkey = $keys[$count - 1];       if ($firstkey === 0 && is_int($lastkey) && ($lastkey + 1) == $count) {           $is_continuous = true;           $expected = 0;           foreach ($keys as $actual) {               if ($actual != $expected) {                   $is_continuous = false;                   break;               }               $expected++;           }           if ($is_continuous) {               $arr = array();               foreach ($php_val as $k => $v) {                   $arr[$k] = XML_RPC_encode($v);               }               $XML_RPC_val->addArray($arr);               break;           }       }       // fall though if not numerical and continuous   case "object":       $arr = array();       foreach ($php_val as $k => $v) {           $arr[$k] = XML_RPC_encode($v);       }       $XML_RPC_val->addStruct($arr);       break;   case "integer":       $XML_RPC_val->addScalar($php_val, $XML_RPC_Int);       break;   case "double":       $XML_RPC_val->addScalar($php_val, $XML_RPC_Double);       break;   case "string":   case "NULL":       $XML_RPC_val->addScalar($php_val, $XML_RPC_String);       break;   // <G_Giunta_2001-02-29>   // Add support for encoding/decoding of booleans, since they are supported in PHP   case "boolean":       $XML_RPC_val->addScalar($php_val, $XML_RPC_Boolean);       break;   // </G_Giunta_2001-02-29>   case "unknown type":   default:       $XML_RPC_val = false;       break;   }   return $XML_RPC_val;}?>