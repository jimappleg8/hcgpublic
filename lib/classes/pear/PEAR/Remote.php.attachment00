        if ($use_proxy && $proxy_host != '' && $proxy_user != '') {            $req_headers .= 'Proxy-Authorization: Basic '                .base64_encode($proxy_user.':'.$proxy_pass)                ."\r\n";        }        if ($this->config->get('verbose') > 3) {            print "XMLRPC REQUEST HEADERS:\n";            var_dump($req_headers);            print "XMLRPC REQUEST BODY:\n";            var_dump($request);        }        if ($use_proxy && $proxy_host != '') {            $post_string = "POST http://".$server_host;            if ($proxy_port > '') {                $post_string .= ':'.$server_port;            }        } else {            $post_string = "POST ";        }        fwrite($fp, ($post_string."/xmlrpc.php$maxAge HTTP/1.0\r\n$req_headers\r\n$request"));        $response = '';        $line1 = fgets($fp, 2048);        if (!preg_match('!^HTTP/[0-9\.]+ (\d+) (.*)!', $line1, $matches)) {            return $this->raiseError("PEAR_Remote: invalid HTTP response from XML-RPC server");        }        switch ($matches[1]) {            case "200": // OK                break;            case "304": // Not Modified                return $this->cache['content'];            case "401": // Unauthorized                if ($username && $password) {                    return $this->raiseError("PEAR_Remote: authorization failed", 401);                } else {                    return $this->raiseError("PEAR_Remote: authorization required, please log in first", 401);                }            default:                return $this->raiseError("PEAR_Remote: unexpected HTTP response", (int)$matches[1], null, null, "$matches[1] $matches[2]");        }        while (trim(fgets($fp, 2048)) != ''); // skip rest of headers        while ($chunk = fread($fp, 10240)) {            $response .= $chunk;        }        fclose($fp);        if ($this->config->get('verbose') > 3) {            print "XMLRPC RESPONSE:\n";            var_dump($response);        }        $ret = xmlrpc_decode($response);        if (is_array($ret) && isset($ret['__PEAR_TYPE__'])) {            if ($ret['__PEAR_TYPE__'] == 'error') {                if (isset($ret['__PEAR_CLASS__'])) {                    $class = $ret['__PEAR_CLASS__'];                } else {                    $class = "PEAR_Error";                }                if ($ret['code']     === '') $ret['code']     = null;                if ($ret['message']  === '') $ret['message']  = null;                if ($ret['userinfo'] === '') $ret['userinfo'] = null;                if (strtolower($class) == 'db_error') {                    $ret = $this->raiseError(PEAR::errorMessage($ret['code']),                                             $ret['code'], null, null,                                             $ret['userinfo']);                } else {                    $ret = $this->raiseError($ret['message'], $ret['code'],                                             null, null, $ret['userinfo']);                }            }        } elseif (is_array($ret) && sizeof($ret) == 1 && isset($ret[0])                  && is_array($ret[0]) &&                  !empty($ret[0]['faultString']) &&                  !empty($ret[0]['faultCode'])) {            extract($ret[0]);            $faultString = "XML-RPC Server Fault: " .                 str_replace("\n", " ", $faultString);            return $this->raiseError($faultString, $faultCode);        }        return $ret;    }    // }}}    // {{{ _encode    // a slightly extended version of XML_RPC_encode    function _encode($php_val)    {        global $XML_RPC_Boolean, $XML_RPC_Int, $XML_RPC_Double;        global $XML_RPC_String, $XML_RPC_Array, $XML_RPC_Struct;        $type = gettype($php_val);        $xmlrpcval = new XML_RPC_Value;        switch($type) {            case "array":                reset($php_val);                $firstkey = key($php_val);                end($php_val);                $lastkey = key($php_val);                if ($firstkey === 0 && is_int($lastkey) &&                    ($lastkey + 1) == count($php_val)) {                    $is_continuous = true;                    reset($php_val);                    $size = count($php_val);                    for ($expect = 0; $expect < $size; $expect++, next($php_val)) {                        if (key($php_val) !== $expect) {                            $is_continuous = false;                            break;                        }                    }                    if ($is_continuous) {                        reset($php_val);                        $arr = array();                        while (list($k, $v) = each($php_val)) {                            $arr[$k] = $this->_encode($v);                        }                        $xmlrpcval->addArray($arr);                        break;                    }                }                // fall though if not numerical and continuous            case "object":                $arr = array();                while (list($k, $v) = each($php_val)) {                    $arr[$k] = $this->_encode($v);                }                $xmlrpcval->addStruct($arr);                break;            case "integer":                $xmlrpcval->addScalar($php_val, $XML_RPC_Int);                break;            case "double":                $xmlrpcval->addScalar($php_val, $XML_RPC_Double);                break;            case "string":            case "NULL":                $xmlrpcval->addScalar($php_val, $XML_RPC_String);                break;            case "boolean":                $xmlrpcval->addScalar($php_val, $XML_RPC_Boolean);                break;            case "unknown type":            default:                return null;        }        return $xmlrpcval;    }    // }}}}?>